//created on: 29-oct-2025
package com.sample.rules

//list any import classes here.


import clasesProyecto.Resultado;
import clasesProyecto.EntradaElectro;
import clasesProyecto.Onda;
import enums.Enfermedades;
import enums.Tipos_Ondas;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;
import segmentosOndas.SegmentoQT;
import segmentosOndas.OndasT;
import segmentosOndas.RelacionTR;


// regla para calcular número de ciclos 
//casting necesario a float en numCiclos porque el MathCeil (redondeo hacia arriba) devulve double
//collect coge todas las ondas existentes y, si es hay alguna onda, crea una lista temporal $ondas con esas ondas

rule "Calcular numCiclos"
	when
		$r: Resultado(numCiclos == 0)
		$ondas: List(size > 0) from collect(Onda())
	then
		float numCiclos = (float) Math.ceil($ondas.size() / 5.0f); 
		modify($r) {
			setNumCiclos(numCiclos);
		}
		System.out.println("Numero de ciclos calculado: " + $r.getNumCiclos());
end


// regla para calcular el ritmo cardiaco
//casting necesario a List para que deje aplicar getInicio y getFin
//necesario hacer un sort porque al parecer las Ondas no estan en orden en $ondas
// (y por tanto tampoco en ondas tras el casting) y salen valores extraños

rule "Calcular ritmoCardiaco"
	when
		$r: Resultado(numCiclos > 0, ritmoCardiaco == 0)
		$ondas: List(size > 0) from collect(Onda());
	then
		List<Onda> ondas = (List<Onda>) $ondas;
		ondas.sort(Comparator.comparing(onda -> onda.getInicio()));
		

//		int resto = ondas.size() % 4;
//		
//		if (resto != 0) {
//    		for(int i = 0; i < resto; i++) {
//    			ondas.remove(ondas.size() -1);
//    		}
//    	}
		
		float inicioPrimeraOnda = ondas.get(0).getInicio();
		float finalUltimaOnda = ondas.get(ondas.size() -1).getFin();
		
		float duracionTotal = finalUltimaOnda - inicioPrimeraOnda;
		float duracionMedia = duracionTotal / $r.getNumCiclos();
		float ritmoCardiaco = 60000.f / duracionMedia;
		
		modify ($r) {
			setRitmoCardiaco(ritmoCardiaco);
		}
		
		System.out.println("Ritmo Cardiaco calculado: " + $r.getRitmoCardiaco());
end


rule "Filtrar segmento QT"
	when
		$entradaElectro: EntradaElectro(listaOndas.size() > 0)
		$segmentoQT: SegmentoQT(listaOndasQT.size() == 0)
	then
		
		List<Onda> segmentoQT = new ArrayList<>();
		List<Onda> todas = $entradaElectro.getListaOndas();
		
		System.out.println("lista creadas");
		
		todas.stream()
		.filter( onda ->
		    onda.getTipo() == Tipos_Ondas.Q ||
	        onda.getTipo() == Tipos_Ondas.R ||
	        onda.getTipo() == Tipos_Ondas.S ||
	        onda.getTipo() == Tipos_Ondas.T
		)
		.forEach(onda -> segmentoQT.add(onda));
		
		System.out.println("filtrado hehco");
		
		int resto = segmentoQT.size() % 4;
    	
    	if (resto != 0) {
    		for(int i = 0; i < resto; i++) {
    			segmentoQT.remove(segmentoQT.size() -1);
    		}
    	}
    	
    	System.out.println("stream hecho");
			
		modify ($segmentoQT) {
			setListaOndasQT(segmentoQT);
		}
		
		System.out.println("modify hecho");
	
end



rule "Detectar Taquicardia"
	when 
		$r: Resultado (ritmoCardiaco > 100 &&
					   enfermedad == null) 
	then
		modify ($r) {
			setEnfermedad(Enfermedades.TAQUICARDIA);
		}
		System.out.println("Detectada posible taquicardia. Ritmo cardiaco alto: " + $r.getRitmoCardiaco());
end


rule "Detectar Bradicardia"
	when 
		$r: Resultado (ritmoCardiaco < 60 &&
				       enfermedad == null)
	then
		modify($r) {
			setEnfermedad(Enfermedades.BRADICARDIA);
		}
		System.out.println("Detectada posible bradicardia. Ritmo cardiaco bajo: " + $r.getRitmoCardiaco());
end

//SUPUESTAMENTE LA DURACION DEL SEGMENTO QT ERA QUE TENIA QUE SER MAYOR A 450, PERO EN  
//LA MAYORIA DE FICHEROS, ESTE VALOR ES 400, EN LOS DE HIPOCALCMIA 407-408. POR 
//LO QUE TOMO QUE EL VALOR SEA SUPERIOR A 400 PARA EL CORRECTO DIAGNOSTICO

/*

rule "Detectar Hipocalcemia"
	when
		$r: Resultado (ritmoCardiaco > 0 && enfermedad == null)
		$segQT: SegmentoQT (listaOndasQT.size > 0)
	then
		List<Onda> ondasQT = $segQT.getListaOndasQT();
		float sumaDuraciones = 0;
		int ciclos = ondasQT.size() / 4;
		
		for (int i = 0; i < ondasQT.size(); i = i + 4) {
			float inicioQ = ondasQT.get(i).getInicio();
			float finT = ondasQT.get(i+3).getFin();
			sumaDuraciones = sumaDuraciones + (finT - inicioQ);
		}
		
		float duracionMedia = sumaDuraciones / ciclos;
		
		if(duracionMedia > 400) {
			modify ($r) {
			setEnfermedad(Enfermedades.HIPOCALCEMIA);
			}
			System.out.println("Detectada posible bradicardia. Duración promedia segmento QT: " + duracionMedia + " ms");
		}
end


rule "Detectar Hipopotasemia"
	when
		$r: Resultado (ritmoCardiaco > 0 && enfermedad == null)
		$ondasT: OndasT (listaOndasT.size > 0)
		$relacionTR: RelacionTR (listaRelacionTR.size > 0)
	then
		List<Onda> ondasT = $ondasT.getListaOndasT();
		List<Onda> relacionTR = $relacionTR.getListaRelacionTR();
		
		// 1º condicion
		float sumaPicosT = 0;
		
		for (int i = 0; i < ondasT.size(); i++) {
			float valAbsPico = Math.abs(ondasT.get(i).getPico());
			sumaPicosT = sumaPicosT + valAbsPico;
		}
		float mediaSumaPicosT = sumaPicosT / ondasT.size();
		
		// 2º condicion
		float sumaRelacionesTR = 0;
		
		for(int i = 0; i < relacionTR.size(); i = i + 2) {
			float picoValAbsR = Math.abs(relacionTR.get(i).getPico());
			float picoValAbsT = Math.abs(relacionTR.get(i+1).getPico());
			
			float relTR = picoValAbsT / picoValAbsR;
			sumaRelacionesTR = sumaRelacionesTR + relTR;
		}
		float mediaRelacionesTR = sumaRelacionesTR / (relacionTR.size() / 2);
		
		//si ambas condiciones se cumplen, diagnosticamos hipopotasemia
		
		if(mediaSumaPicosT < 0.1 || mediaRelacionesTR < 0.2) {
			modify($r) {
				setEnfermedad(Enfermedades.HIPOPOTASEMIA);
			}
			System.out.println("Detectada posible hipopotasemia");
			System.out.println("Media Picos T: " + mediaSumaPicosT);
			System.out.println("Media RelacionTR: " + mediaRelacionesTR); 
		}
end

*/










